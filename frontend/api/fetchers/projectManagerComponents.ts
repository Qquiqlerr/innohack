/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import type * as Fetcher from "./projectManagerFetcher";
import { projectManagerFetch } from "./projectManagerFetcher";
import type * as Schemas from "./projectManagerSchemas";

export type GetAllProjectsError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorResponse;
}>;

export type GetAllProjectsResponse = Schemas.Project[];

/**
 * Получить список проектов
 */
export const getAllProjects = (signal?: AbortSignal) =>
  projectManagerFetch<
    GetAllProjectsResponse,
    GetAllProjectsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/projects", method: "get", signal });

export type CreateProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResponse;
}>;

export type CreateProjectVariables = {
  body?: Schemas.Project;
};

/**
 * Создать проект с необходимыми полями
 */
export const createProject = (
  variables: CreateProjectVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    Schemas.Project,
    CreateProjectError,
    Schemas.Project,
    {},
    {},
    {}
  >({ url: "/projects", method: "post", ...variables, signal });

export type UpdateProjectPathParams = {
  id: number;
};

export type UpdateProjectError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResponse;
    }
>;

export type UpdateProjectVariables = {
  body?: Schemas.Project;
  pathParams: UpdateProjectPathParams;
};

/**
 * Обновить проект по его ID
 */
export const updateProject = (
  variables: UpdateProjectVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    Schemas.Project,
    UpdateProjectError,
    Schemas.Project,
    {},
    {},
    UpdateProjectPathParams
  >({ url: "/projects/{id}", method: "put", ...variables, signal });

export type DeleteProjectPathParams = {
  id: number;
};

export type DeleteProjectError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResponse;
}>;

export type DeleteProjectVariables = {
  pathParams: DeleteProjectPathParams;
};

/**
 * Удалить проект по его ID
 */
export const deleteProject = (
  variables: DeleteProjectVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    undefined,
    DeleteProjectError,
    undefined,
    {},
    {},
    DeleteProjectPathParams
  >({ url: "/projects/{id}", method: "delete", ...variables, signal });

export type GetAllTasksQueryParams = {
  /**
   * ID проекта для фильтрации задач
   */
  projectID?: number;
  /**
   * Статус задач для фильтрации(0 - ожидает, 1 - в работе, 2 - выполнена)
   */
  status?: number;
};

export type GetAllTasksError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ErrorResponse;
}>;

export type GetAllTasksResponse = Schemas.Task[];

export type GetAllTasksVariables = {
  queryParams?: GetAllTasksQueryParams;
};

/**
 * Получить список задач с возможностью фильтрации по `projectID` и `status`
 */
export const getAllTasks = (
  variables: GetAllTasksVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    GetAllTasksResponse,
    GetAllTasksError,
    undefined,
    {},
    GetAllTasksQueryParams,
    {}
  >({ url: "/tasks", method: "get", ...variables, signal });

export type CreateTaskError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResponse;
}>;

export type CreateTaskVariables = {
  body?: Schemas.Task;
};

/**
 * Создать задачу с необходимыми полями
 */
export const createTask = (
  variables: CreateTaskVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<Schemas.Task, CreateTaskError, Schemas.Task, {}, {}, {}>({
    url: "/tasks",
    method: "post",
    ...variables,
    signal,
  });

export type UpdateTaskPathParams = {
  id: number;
};

export type UpdateTaskError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResponse;
    }
>;

export type UpdateTaskVariables = {
  body?: Schemas.Task;
  pathParams: UpdateTaskPathParams;
};

/**
 * Обновить задачу по ее ID
 */
export const updateTask = (
  variables: UpdateTaskVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    Schemas.Task,
    UpdateTaskError,
    Schemas.Task,
    {},
    {},
    UpdateTaskPathParams
  >({ url: "/tasks/{id}", method: "put", ...variables, signal });

export type DeleteTaskPathParams = {
  id: number;
};

export type DeleteTaskError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResponse;
}>;

export type DeleteTaskVariables = {
  pathParams: DeleteTaskPathParams;
};

/**
 * Удалить задачу по ее ID
 */
export const deleteTask = (
  variables: DeleteTaskVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    undefined,
    DeleteTaskError,
    undefined,
    {},
    {},
    DeleteTaskPathParams
  >({ url: "/tasks/{id}", method: "delete", ...variables, signal });

export type LoginUserError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.ErrorResponse;
}>;

export type LoginUserVariables = {
  body?: Schemas.LoginRequest;
};

/**
 * Аутентифицировать пользователя по email и паролю
 */
export const loginUser = (
  variables: LoginUserVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    Schemas.AuthResponse,
    LoginUserError,
    Schemas.LoginRequest,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export type RegisterUserError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResponse;
}>;

export type RegisterUserVariables = {
  body?: Schemas.RegisterRequest;
};

/**
 * Зарегистрировать нового пользователя
 */
export const registerUser = (
  variables: RegisterUserVariables,
  signal?: AbortSignal,
) =>
  projectManagerFetch<
    Schemas.AuthResponse,
    RegisterUserError,
    Schemas.RegisterRequest,
    {},
    {},
    {}
  >({ url: "/auth/register", method: "post", ...variables, signal });

export const operationsByTag = {
  api: { getAllProjects, createProject, updateProject, deleteProject },
  tasks: { getAllTasks, createTask, updateTask, deleteTask },
  auth: { loginUser, registerUser },
};
